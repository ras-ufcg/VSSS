#ifndef GENERIC_PLAYER_H
#define GENERIC_PLAYER_H

#include "Goleiro_Azul.hpp"
#include "Goleiro_Amarelo.hpp"


/**
 * @brief Guarda a lógica de funcionamento do jogador de camisa vermelha (goleiro)
 *
 */
class GenericPlayer
{
private:
	vss::TeamType _teamType;

public:

	GenericPlayer(vss::TeamType type)
	{
		this->_teamType = type;
	}

	/**
	 * @brief Função chamada a cada atualização com informações novas
	 *
	 * @param state Estado atual do jogo
	 * @param index Indice do robo que se deseja atualizar
	 * @return vss::WheelsCommand Comandos para as rodas do robo que se deseja atualizar
	 */
	vss::WheelsCommand update(vss::State state, int index)
	{
		Utils::Posture objective = defineObjective(state, index);
		return motionControl(state, objective, index);
	}

	/**
	 * @brief Define a postura final que se deseja chegar na iteração atual
	 *
	 * @param index Indice do robo que se deseja atualizar
	 * @return Posture Posiçãoque se deseja adquirir
	 */
	Utils::Posture defineObjective(vss::State state, int index)
	{

		return (this->_teamType == vss::TeamType::Blue) ? blueObjective(state, index) : yellowObjective(state, index);
	}

	// TODO criar (ou usar um existente) typedef para calcular as duas variações em uma única função
	// e retornar os dois valores em uma única variável

	/**
	 * @brief Traduz o objetivo desejado em velocidade das rodas utilizando o algoritmo Motion Control presente
	 * no livro Autonomous Mobile Robots, Siegwart
	 *
	 * @param state Situação de jogo atual
	 * @param objective Posição que se deseja chegar
	 * @param index Indice do robo que se deseja atualizar
	 * @return vss::WheelsCommand Comandos para as rodas do robo que se deseja atualizar
	 */
	vss::WheelsCommand motionControl(vss::State state, Utils::Posture objective, int index)
	{
		vss::WheelsCommand result;
		double  alpha, beta, rho, lambda;
		double linearSpeed, angularSpeed;

		double kRho = 1.85, kAlpha = 9.7, kBeta = -0.01;

		vss::Robot robot = (this->_teamType == vss::TeamType::Blue) ? state.teamBlue[index] : state.teamYellow[index];

		robot.angle = Utils::to180range(robot.angle * M_PI / 180.0);

		rho = Utils::distance(doublePair(objective.x, objective.y), doublePair(robot.x, robot.y));

		lambda = atan2(objective.y - robot.y, objective.x - robot.x);

		if (rho < 3)
			lambda = 0;

		alpha = Utils::to180range(lambda - robot.angle);
		beta = -lambda + objective.angle;

		linearSpeed = -kRho * rho;
		angularSpeed = kAlpha * alpha + kBeta * beta;

		double constantSpeed = 60;
		double scale = constantSpeed / linearSpeed;
		linearSpeed *= scale;
		angularSpeed *= scale;

		if (rho < 3)
		{
			linearSpeed = 0;
			angularSpeed *= 0.4;
		}

		if (fabs(alpha) > 0.5 * M_PI)
		{
			linearSpeed = -linearSpeed;
		}

		result.leftVel = (linearSpeed - angularSpeed * 3.35) / 2.;
		result.rightVel = (linearSpeed + angularSpeed * 3.35) / 2.;

		double maxSpeed = std::max(fabs(result.leftVel), fabs(result.rightVel));

		if (maxSpeed > 100)
		{
			result.leftVel *= 100 / fabs(maxSpeed);
			result.rightVel *= 100 / fabs(maxSpeed);
		}

		return result;
	}

};

#endif
